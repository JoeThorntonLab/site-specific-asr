---
title: "Empirical data analysis"
author: "Ricardo Mu√±iz Trejo"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      message = FALSE)
```

```{r set up necessary data for analysis}

#Load all required packages
requiredPackages <- c("tidyverse", "ggrepel", "svglite", "ape", "ggtree", "treeio", "viridis", "DescTools", "ggsignif", "data.table", "psych", "reshape2", "here")
lapply(requiredPackages, require, character.only = TRUE)
rm(requiredPackages)

#Set theme for all plots
theme_set(theme_classic())
theme_update(panel.grid = element_blank(),
             panel.background = element_blank(),
             aspect.ratio = 1)

# Set working directory to empirical directory
data.path <- file.path(paste0(here(), "/empirical/data/"))
results.path <- file.path(paste0(here(), "/empirical/results/"))


# Basic parameters of each system
sr.alignment.size <- 76
sr.tips <- 70
sr.model.list <- c("C_teleta_SR", "HsMR", "JTT", "Poisson") 

rbd.alignment.size <- 182
rbd.tips <- 37
rbd.model.list <- c("SARS_CoV_2", "WAG", "Poisson") 

ha.alignment.size <- 550
ha.tips <- 92
ha.model.list <- c("H1", "H3", "FLU", "Poisson") 


```

# Load additional data for analysis

For the analysis of empirical data, we wanted to identify sites throughout the
tree that would be reconstructed as gaps given that there are some historical
indels in the alignments. Typically, maximum likelihood ASR does not identify 
these sites as gaps. Instead, it assigns states based on the empirical frequencies, 
causing disagreements between reconstructions that are artifactual. To account,
for these artifacts, we performed parsimony based ASR to identify sites that should 
be reconstructed as gaps using Mesquite 3.70 (Maddison and Maddison 2021). To 
simplify, we recoded the alignments to contain two states, G for sites with gaps, 
and A for sites with an amino acid states. The resulting reconstructions, then, 
can only have As or Gs, indicating the absence/presence of gaps in the reconstructions,
respectively. These reconstructions are stored in a table in data/. The node numbers
in those tables were modified to match the node numbering produced by DMSPhyloAA.

The following chunk contains the  function, clean_gap_data, that takes the gap 
reconstructions and puts them in a long format to later merge them with the 
comparison between model reconstructions, so that we can correct for sites that 
should be reconstructed as gaps.


```{r load parsimony gap data, include=FALSE, warning=FALSE}


clean_gap_data <- function(path){
  
  # Read data from gaps in reconstructions
  parsimony <- setDT(read.csv(SR_gap_file, header = TRUE))
  
  # Change table to long format by transforming all nodes into a single column
  parsimony <- setDT(melt(parsimony, id.vars = "site", 
                    measured.vars = 2:ncol(parsimony), 
                    variable.name = "node"))
  
  # Reading the data adds a "X" to node names, change to actual node numbers
  parsimony[, node := as.numeric(gsub("[^0-9]", "", node))]
  
  # Reformat variable to be more explicit about the presence/absence of a gap
  # in the reconstruction process and simplify
  parsimony[, gap := ifelse(value == "G", "gap", "no_gap")]
  parsimony <- parsimony[, c("site", "node", "gap")]
  
  return(parsimony)

}

SR_gap_file <- file.path(paste0(data.path, "/sr_parsimony_gaps.csv"))
HA_gap_file <- file.path(paste0(data.path, "/ha_parsimony_gaps.csv"))
RBD_gap_file <- file.path(paste0(data.path, "/rbd_parsimony_gaps.csv"))

SR_gaps <- clean_gap_data(SR_gap_file)
HA_gaps <- clean_gap_data(HA_gap_file)
RBD_gaps <- clean_gap_data(RBD_gap_file)

```


## Comparison of ancestral reconstructions between models



```{r ML set comparison}

# This function takes in two model names, an alignment size, a path to the model data,
# and a vector of gaps.
# It reconstructs the sequences for each node in the models, compares them, and stores
# the results in a data table.
# If a gap is detected at a given site, the "true_mismatch" column is set to "identical".
# Otherwise, the "true_mismatch" column reflects the comparison result from "mismatch" column.
compare_ml_states <- function(model_1, model_2, alignment_size, gaps) {
  
  # Create a site vector from 1 to the alignment size
  site <- 1:alignment_size
  
  # Get list of node files for reconstruction
  node_file_list <- list.files(path = file.path(results.path, model_1, "ASR"), pattern = "[0-9]{1,3}\\.txt")
  
  # Pre-allocate output data table with columns for node, site, model 1, model 2,
  # mismatch, and true_mismatch
  site_comparison <- data.table(node = integer(), 
                           site = integer(), 
                           model_1 = character(),
                           model_2 = character(),
                           mismatch = character(),
                           stringsAsFactors = FALSE)
  
  # Loop over nodes to reconstruct sequences and compare
  for (i in seq_along(node_file_list)) {
    
    # Get node number from filename
    node_number <- rep(parse_number(node_file_list[i]), 
                       times = alignment_size)  
    
    # Load sequences for both models
    model_1_sequence <- readLines(file.path(results.path, model_1, "ASR", node_file_list[[i]]))
    model_2_sequence <- readLines(file.path(results.path, model_2, "ASR", node_file_list[[i]]))
    
    # Compare sequences and record results
    mismatch_ml <- +(charToRaw(model_1_sequence) != charToRaw(model_2_sequence))
    mismatch_ml <- ifelse(mismatch_ml == 0, "identical", "disagreement")
    
    # Bind the node, site, model 1, model 2, and mismatch columns to the output data table
    site_comparison <- rbind(site_comparison, data.table(node = node_number,
                                         site = site, 
                                         model_1 = strsplit(model_1_sequence, split = "")[[1]],
                                         model_2 = strsplit(model_2_sequence, split = "")[[1]],
                                         mismatch = mismatch_ml))
  }
  
  # Add the gaps vector as a column to the output data table
  site_comparison <- merge(site_comparison, gaps, by = c("node", "site"))
  
  # Set the "true_mismatch" column to "identical" where gaps are detected,
  # otherwise it reflects the comparison result from the "mismatch" column
  site_comparison[, true_mismatch := ifelse(gap == "gap", "identical", mismatch)]
  
  
  # Extract model name
  model_1 <- sub(".*_", "", model_1) 
  model_2 <- sub(".*_", "", model_2)
  
  # Set column names
  setnames(site_comparison, c("node", "site", "model_1", "model_2", "mismatch", "gap", "true_mismatch"), 
           c("node", "site", model_1, model_2, "mismatch", "gap", "true_mismatch"))
  
  # Convert true_mismatch to a factor with levels "identical" and "disagreement"
  site_comparison$true_mismatch <- factor(site_comparison$true_mismatch, levels = c("identical", "disagreement"))
  
  # Return the output data table
  return(site_comparison)
}




# A function to summarize the number and percentage of disagreements in a comparison table
# Takes a data table as input
summarise_model_comparison <- function(compare_table){
  # Group the table by the true_mismatch column and count the number of occurrences of each value
  summary_table <- compare_table[, .(count = .N), by = true_mismatch][,
    # Calculate the percentage of occurrences for each true_mismatch value 
    percentage := count/nrow(compare_table)*100][]
  # Return the summary table
  return(summary_table)
}






summarise_disagreements <- function(compared_models_table, alignment_size) {
  # For number and proportion of identical and disagreeing states
  disagreement_value_state <- summarise_model_comparison(compared_models_table)
  identical_states <- disagreement_value_state[true_mismatch == "identical", .(count)]$count
  identical_states_percent <- disagreement_value_state[true_mismatch == "identical", .(percentage)]$percentage
  disagreement_states <- ifelse("disagreement" %in% disagreement_value_state$true_mismatch,
                                disagreement_value_state[true_mismatch == "disagreement", .(count)]$count,
                                0)
  disagreement_states_percent <- ifelse("disagreement" %in% disagreement_value_state$true_mismatch,
                                         disagreement_value_state[true_mismatch == "disagreement", .(percentage)]$percentage,
                                         0)
  
  # For proportion of nodes with disagreements
  total_nodes <- nrow(compared_models_table) / alignment_size
  disagreement_value_node <- nrow(compared_models_table[true_mismatch == "disagreement", .N, by = node])
  disagreement_nodes <- disagreement_value_node
  disagreement_nodes_percent <- (disagreement_value_node / total_nodes) * 100

  summary_disagreements <- data.frame(model_1 = colnames(compared_models_table)[3],
                                      model_2 = colnames(compared_models_table)[4],
                                      identical_states, disagreement_states,
                                      identical_states_percent, disagreement_states_percent,
                                      total_nodes, disagreement_nodes, disagreement_nodes_percent)

  return(summary_disagreements)
}




sr.model.list <- c("SS-ER", "SS-MR", "JTT", "Poisson") 
ha.model.list <- c("H1", "H3", "FLU", "Poisson") 
rbd.model.list <- c("SARS_CoV_2", "WAG", "Poisson") 


## SR DBD with only 3 DMS datasets

# Generate all pairwise combinations and self-comparison of models
model_pairs <- combn(sr.results, 2)
self_comparisons <- t(matrix(sr.results, nrow = length(sr.results), ncol = 2))
#model_pairs <- cbind(model_pairs, self_comparisons)




sr.results <- list.files(path = results.path, pattern = "sr",
                         recursive = FALSE, full.names = FALSE, include.dirs = TRUE)

rbd.results <- list.files(path = results.path, pattern = "rbd",
                         recursive = FALSE, full.names = FALSE, include.dirs = TRUE)

ha.results <- list.files(path = results.path, pattern = "ha",
                         recursive = FALSE, full.names = FALSE, include.dirs = TRUE)

# Loop over each pairwise combination and compare models
SR_model_comparison_list <- lapply(seq_len(ncol(model_pairs)), function(i) {
  compare_ml_states(model_pairs[1, i], model_pairs[2, i], sr.alignment.size, SR_gaps)
})


function(dt_list){

  model_comparison <- data.table(true_mismatch = character(), 
                           count = integer(), 
                           percentage = numeric(),
                           model_a = character(),
                           model_b = character(),
                           stringsAsFactors = FALSE)
  
  for(i in 1:length(SR_model_comparison_list)){
  
  site_comparison <- SR_model_comparison_list[[i]]
  site_comparison <- site_comparison[, .(count = .N), by = true_mismatch][,
    # Calculate the percentage of occurrences for each true_mismatch value 
    percentage := count/nrow(site_comparison)*100][]
  
  model_a <- sub(".*_", "", model_pairs[1, i]) 
  model_b <- sub(".*_", "", model_pairs[2, i])
  
  site_comparison[, model_a := model_a]
  site_comparison[, model_b := model_b]
  
  model_comparison <- rbind(model_comparison, site_comparison)
  }
  
  self_comparisons
  
  
}


ggplot(model_comparison[true_mismatch == "identical"], aes(x = model_a, y = model_b)) +
  geom_tile(color = "black", fill = "white") +
  geom_text(aes(label = round(percentage, digits = 1)), size = 8) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        aspect.ratio = 1) +
  labs(x = "ML states",
       y = "ML states",
       fill = "Identity (%)")




plot.main.comparison <- function(table, color_choice){
  plot <- ggplot(table, aes(x = model_1, y = model_2)) +
  geom_tile(color = "black", fill = color_choice) +
  geom_text(aes(label = round(identical_states_percent, digits = 1)), size = 8) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        aspect.ratio = 1) +
  labs(x = "ML states",
       y = "ML states",
       fill = "Identity (%)")
  return(plot)
}








# Summarise identical and disagreeing states into a data frame
SR_model_disagreements_table <- data.frame()

for(i in 1:length(SR_model_comparison_list)){
  model_disagreement_data <- summarise_disagreements(SR_model_comparison_list[[i]], 
                          sr.alignment.size)
    SR_model_disagreements_table <- rbind(SR_model_disagreements_table, 
                                        model_disagreement_data)
}

# Organize models by their AIC value
SR_model_disagreements_table$model_1 <- factor(SR_model_disagreements_table$model_1, levels = sr.model.list)
SR_model_disagreements_table$model_2 <- factor(SR_model_disagreements_table$model_2, levels = rev(sr.model.list))

# SARS-CoV-2 RBD
# Generate all pairwise combinations and self-comparison of models
model_pairs <- combn(rbd.model.list, 2)
self_comparisons <- t(matrix(rbd.model.list, nrow = length(rbd.model.list), ncol = 2))
model_pairs <- cbind(model_pairs, self_comparisons)


# Loop over each pairwise combination and compare models
RBD_model_comparison_list <- lapply(seq_len(ncol(model_pairs)), function(i) {
  compare_ml_states(model_pairs[1, i], model_pairs[2, i], rbd.alignment.size, rbd.path, RBD_gaps)
})

# Summarise identical and disagreeing states into a data frame
RBD_model_disagreements_table <- data.frame()

for(i in 1:length(RBD_model_comparison_list)){
  model_disagreement_data <- summarise_disagreements(RBD_model_comparison_list[[i]], 
                          rbd.alignment.size)
    RBD_model_disagreements_table <- rbind(RBD_model_disagreements_table, 
                                        model_disagreement_data)
}

# Organize models by their AIC value
RBD_model_disagreements_table$model_1 <- factor(RBD_model_disagreements_table$model_1, levels = rbd.model.list)
RBD_model_disagreements_table$model_2 <- factor(RBD_model_disagreements_table$model_2, levels = rev(rbd.model.list))


# Hemagglutinin

# Generate all pairwise combinations and self-comparison of models
model_pairs <- combn(ha.model.list, 2)
self_comparisons <- t(matrix(ha.model.list, nrow = length(ha.model.list), ncol = 2))
model_pairs <- cbind(model_pairs, self_comparisons)


# Loop over each pairwise combination and compare models
HA_model_comparison_list <- lapply(seq_len(ncol(model_pairs)), function(i) {
  compare_ml_states(model_pairs[1, i], model_pairs[2, i], ha.alignment.size, ha.path, HA_gaps)
})

# Summarise identical and disagreeing states into a data frame
HA_model_disagreements_table <- data.frame()

for(i in 1:length(HA_model_comparison_list)){
  model_disagreement_data <- summarise_disagreements(HA_model_comparison_list[[i]], 
                          ha.alignment.size)
    HA_model_disagreements_table <- rbind(HA_model_disagreements_table, 
                                        model_disagreement_data)
}

# Organize models by their AIC value
HA_model_disagreements_table$model_1 <- factor(HA_model_disagreements_table$model_1, levels = ha.model.list)
HA_model_disagreements_table$model_2 <- factor(HA_model_disagreements_table$model_2, levels = rev(ha.model.list))

```


```{r}


SR_model_comparison_list[[2]]
write.csv(SR_model_comparison_list[[2]], file = "SR_SS_SH_data.csv", row.names = FALSE)


HA_model_comparison_list[[2]]
write.csv(HA_model_comparison_list[[2]], file = "HA_SS_SH_data.csv", row.names = FALSE)

RBD_model_comparison_list[[1]]
write.csv(RBD_model_comparison_list[[1]], file = "RBD_SS_SH_data.csv", row.names = FALSE)

```


## Load site specific data

```{r append site-specific data to the comparisons}

## Parsimony data ##
read_parsimony_data <- function(node_directory, parsimony_file_path){

  #Get nodes in the same order as they load into R
  node_file_list <- list.files(node_directory, pattern = "[0-9]{1,3}.txt")
  nodes <- c("site", gsub(".*?([0-9]+).*", "\\1", node_file_list))

  # Load parsimony table and correct column names to reflect the node
  parsimony <- read.csv(parsimony_file_path) 
  colnames(parsimony) <- c("site", gsub(".*?([0-9]+).*", "\\1", colnames(parsimony)[-1]))
  
  # Order columns according to how they load into R
  parsimony <- parsimony[, nodes]

  # Put everything into a tibble and modify to reflect ambiguity
  parsimony_data <- parsimony %>%
    gather("node", "pars_state", -1) %>% 
    mutate(pars_amb = ifelse(nchar(pars_state) > 1, "ambiguous", "unambiguous"))

  return(parsimony_data[, c("pars_amb", "pars_state")])
}


## Rate of evolution ##
get_evol_rate <- function(file_path) {
  evol_rates <- read.csv(file_path)
  evol_rates$Posterior.mean
}

## Sequence entropy ##
get_sequence_entropy <- function(file_path) {
  sequence_entropy <- read.csv(file_path)
  sequence_entropy$entropy
}


shannon_entropy <- function(df) {
  # Replace zeros with a small non-zero value
  df[df == 0] <- 1e-20
  
  # Get the Shannon entropy of the values in each row
  entropy <- apply(df, 1, function(x) {
    -sum(x * log(x, base = 20)) # As in 20 amino acid states
  })
  
  # Return the entropy
  return(entropy)
}


max_per_row <- function(df) {
  # Get the maximum value in each row
  max_vals <- apply(df, 1, max)
  
  # Return the maximum values
  return(max_vals)
}

aa_order <- c("A", "R", "N", "D", "C", "Q", "E", "G", "H", "I", 
              "L", "K", "M", "F", "P", "S", "T", "W", "Y", "V")


# Loop over the list and cbind each data table with extra_data
SR_parsimony <- read_parsimony_data(SR_node_order, "C:/Users/rmuniztrejo/Box/empirical_asr/results/empirical/misc/SR_parsimony.csv")
SR_rates <- get_evol_rate("C:/Users/rmuniztrejo/Box/empirical_asr/results/empirical/misc/SR_phyml.csv")
SR_entropy <- get_sequence_entropy("C:/Users/rmuniztrejo/Box/empirical_asr/results/empirical/misc/SR_entropy.csv")


for(i in seq_along(SR_model_comparison_list)) {
  table <- cbind(SR_model_comparison_list[[i]], SR_parsimony)
  table[, true_amb := ifelse(gap == "gap", "unambiguous", pars_amb)]
  SR_model_comparison_list[[i]] <- cbind(table, 
                                         rates = SR_rates, 
                                         entropy = SR_entropy)
}


HA_parsimony <- read_parsimony_data(HA_node_order, "C:/Users/rmuniztrejo/Box/empirical_asr/results/empirical/misc/HA_parsimony.csv")
HA_rates <- get_evol_rate("C:/Users/rmuniztrejo/Box/empirical_asr/results/empirical/misc/HA_phyml.csv")
HA_entropy <- get_sequence_entropy("C:/Users/rmuniztrejo/Box/empirical_asr/results/empirical/misc/HA_entropy.csv")



for(i in seq_along(HA_model_comparison_list)) {
  table <- cbind(HA_model_comparison_list[[i]], HA_parsimony)
  table[, true_amb := ifelse(gap == "gap", "unambiguous", pars_amb)]
  HA_model_comparison_list[[i]] <- cbind(table, 
                                         rates = HA_rates, 
                                         entropy = HA_entropy)
}


RBD_parsimony <- read_parsimony_data(RBD_node_order, "C:/Users/rmuniztrejo/Box/empirical_asr/results/empirical/misc/RBD_parsimony.csv")
RBD_rates <- get_evol_rate("C:/Users/rmuniztrejo/Box/empirical_asr/results/empirical/misc/RBD_phyml.csv")
RBD_entropy <- get_sequence_entropy("C:/Users/rmuniztrejo/Box/empirical_asr/results/empirical/misc/RBD_entropy.csv")


for(i in seq_along(RBD_model_comparison_list)) {
  table <- cbind(RBD_model_comparison_list[[i]], RBD_parsimony)
  table[, true_amb := ifelse(gap == "gap", "unambiguous", pars_amb)]
  RBD_model_comparison_list[[i]] <- cbind(table, 
                                         rates = RBD_rates, 
                                         entropy = RBD_entropy)
}


# The comparisons of C. teleta with HsMR, JTT and Poisson have the index 1, 2,
# and 3, respectively

# The comparisons of H1 with H3, FLU and Poisson have the index 1, 2,
# and 3, respectively

# The comparisons of SARS-CoV-2 with WAG and Poisson have the index 1, and 2,
# respectively

```





```{r plausible set comparison}
# Define function to get the matches between two reconstructed sequences
get_mismatch <- function(seq1, seq2) {
  matches <- charToRaw(seq1) == charToRaw(seq2)
  return(matches)
}

# define function to obtain the AltAll sequences under different ambiguity criteria
get_alt_all_seq <- function(pp_table, threshold, condition) {
  
  # read in the posterior probability table
  table <- read.csv(pp_table)
  
  # create an empty vector to store results
  results <- c()
  
  # loop over each row of the table
  for (i in 1:nrow(table)) {
    
    # find the maximum value in the row
    max_val <- max(table[i,])
    
    # find the index of the maximum value in the row
    # there could be sites with two max values, only pick the first one [1]
    max_index <- which(table[i,] == max_val)[1] 
    
    # find the second highest value in the row
    sorted_row <- sort(table[i,], decreasing=TRUE)
    second_max_val <- sorted_row[2]
    
    # calculate the ratio of the highest to second highest value
    ratio <- max_val/second_max_val
    
    # select the condition to use
    if (condition == "high_second") {
      # if the second highest value is greater than or equal to the threshold
      if (second_max_val > threshold) {
        # add the amino acid with the second highest value to the results vector
        result <- colnames(sorted_row[2])
        results <- c(results, result)
        
      } else {
        # add the amino acid with the highest value if the condition is not met
        results <- c(results, colnames(table)[max_index])
      }
      
    } else if (condition == "ratio") {
      # if the ratio of the highest to second highest value is less than the threshold
      if (ratio < threshold) {
        # add the amino acid with the second highest value to the results vector
        results <- c(results, colnames(sorted_row[2]))
        
      } else {
        # add the amino acid with the highest value if the condition is not met
        results <- c(results, colnames(table)[max_index])
      }
      
    } else {
      # if the highest value is less than the threshold
      if (max_val < threshold) {
        # add the amino acid with the second highest value to the results vector
        results <- c(results, colnames(sorted_row[2]))
        
      } else {
        # add the amino acid with the highest value to the results vector
        results <- c(results, colnames(table)[max_index])
      }
    }
  }
  
  # return the results vector as a single protein sequence
  return(paste0(results, collapse=""))
}



compare_alt_states <- function(model_1, model_2, alignment_size, model_path, gap_vector) {
  
  # Create a site vector from 1 to the alignment size
  site <- 1:alignment_size
  
  # Get list of node files for reconstruction
  node_file_list <- list.files(path = file.path(model_path, model_1, "ASR"), pattern = "[0-9]{1,3}\\.txt")
  pp_file_list <- list.files(path = file.path(model_path, model_1, "ASR"), pattern = "[0-9]{1,3}_PP.txt")
  
  # Pre-allocate output data table with columns for node, site, model 1, model 2,
  # mismatch, and true_mismatch
  PP_tibble <- data.table(node = integer(), 
                          site = integer(), 
                          model_1_ml = character(),
                          model_2_ml = character(),
                          model_2_alt = character(),
                          mismatch = character(),
                          ml_amb = character(),
                          stringsAsFactors = FALSE)
  
  # Loop over nodes to reconstruct sequences and compare
  for (i in seq_along(node_file_list)) {
    
    # Get node number from filename
    node_number <- rep(parse_number(node_file_list[i]), 
                       times = alignment_size)  
    
    # Load sequences for both models
    model_1_sequence_ml <- readLines(file.path(model_path, model_1, "ASR", node_file_list[[i]]))
    model_2_sequence_ml <- readLines(file.path(model_path, model_2, "ASR", node_file_list[[i]]))
    model_2_sequence_alt <- get_alt_all_seq(file.path(model_path, model_2, "ASR", pp_file_list[[i]]), 0.2, "high_second")
    
    # Compare sequences and record results
    mismatch_ml <- get_mismatch(model_1_sequence_ml, model_2_sequence_ml)
    mismatch_alt <- get_mismatch(model_1_sequence_ml, model_2_sequence_alt)
    mismatch_plausible <- ifelse(mismatch_ml == FALSE & mismatch_alt == FALSE, "disagreement", "identical")
    
    # Determine ambiguity
    get_ambiguity <- get_mismatch(model_2_sequence_ml, model_2_sequence_alt)
    ml_ambiguity <- ifelse(get_ambiguity == TRUE, "unambiguous", "ambiguous")

    # Bind the node, site, model 1, model 2, and mismatch columns to the output data table
    PP_tibble <- rbind(PP_tibble, data.table(node = node_number,
                                         site = site, 
                                         model_1_ml = strsplit(model_1_sequence_ml, split = "")[[1]],
                                         model_2_ml = strsplit(model_2_sequence_ml, split = "")[[1]],
                                         model_2_alt = strsplit(model_2_sequence_alt, split = "")[[1]],
                                         mismatch = mismatch_plausible,
                                         ml_amb = ml_ambiguity))
  }
  
  # Add the gaps vector as a column to the output data table
  gaps <- gap_vector
  PP_tibble <- cbind(PP_tibble, gaps)
  
  # Set the "true_mismatch" column to "identical" where gaps are detected,
  # otherwise it reflects the comparison result from the "mismatch" column
  PP_tibble[, true_mismatch := ifelse(gaps == "gap", "identical", mismatch)]
  
  
  # Set the "true_ml_amb" column to "unambiguous" where gaps are detected,
  # otherwise it reflects the comparison result from the "ml_amb" column
  
  PP_tibble[, true_ml_amb := ifelse(gaps == "gap", "unambiguous", ml_amb)]
  
  # Modify column names
  setnames(PP_tibble, c("node", "site", "model_1_ml", "model_2_ml", "model_2_alt", "mismatch", "ml_amb", "gaps", "true_mismatch", "true_ml_amb"), 
           c("node", "site", model_1, model_2, paste0(model_2, "_alt"), "mismatch", "ml_amb", "gap", "true_mismatch", "true_ml_amb"))
  
  # Convert true_mismatch to a factor with levels "identical" and "disagreement"
  PP_tibble$true_mismatch <- factor(PP_tibble$true_mismatch, levels = c("identical", "disagreement"))
  
  # Return the output data table
  return(PP_tibble)
}

## SR DBD with only 3 DMS datasets

# Generate all pairwise combinations and self-comparison of models
model_pairs <- combn(sr.model.list, 2)
model_pairs_swapped <- apply(model_pairs, 2, rev)
model_pairs <- cbind(model_pairs, model_pairs_swapped)

# Loop over each pairwise combination and compare models
SR_alt_comparison_list <- lapply(seq_len(ncol(model_pairs)), function(i) {
  compare_alt_states(model_pairs[1, i], model_pairs[2, i], sr.alignment.size, sr.path, SR_gaps)
})

# Summarise identical and disagreeing states into a data frame
SR_alt_disagreements_table <- data.frame()

for(i in 1:length(SR_alt_comparison_list)){
  model_disagreement_data <- summarise_disagreements(SR_alt_comparison_list[[i]], 
                          sr.alignment.size)
    SR_alt_disagreements_table <- rbind(SR_alt_disagreements_table, 
                                        model_disagreement_data)
}


# Organize models by their AIC value
SR_alt_disagreements_table$model_1 <- factor(SR_alt_disagreements_table$model_1, levels = rev(sr.model.list))
SR_alt_disagreements_table$model_2 <- factor(SR_alt_disagreements_table$model_2, levels = sr.model.list)


## Hemagglutinin

# Generate all pairwise combinations and self-comparison of models
model_pairs <- combn(ha.model.list, 2)
model_pairs_swapped <- apply(model_pairs, 2, rev)
model_pairs <- cbind(model_pairs, model_pairs_swapped)

# Loop over each pairwise combination and compare models
HA_alt_comparison_list <- lapply(seq_len(ncol(model_pairs)), function(i) {
  compare_alt_states(model_pairs[1, i], model_pairs[2, i], ha.alignment.size, ha.path, HA_gaps)
})

# Summarise identical and disagreeing states into a data frame
HA_alt_disagreements_table <- data.frame()

for(i in 1:length(HA_alt_comparison_list)){
  model_disagreement_data <- summarise_disagreements(HA_alt_comparison_list[[i]], 
                          ha.alignment.size)
    HA_alt_disagreements_table <- rbind(HA_alt_disagreements_table, 
                                        model_disagreement_data)
}

# Organize models by their AIC v
HA_alt_disagreements_table$model_1 <- factor(HA_alt_disagreements_table$model_1, levels = rev(ha.model.list))
HA_alt_disagreements_table$model_2 <- factor(HA_alt_disagreements_table$model_2, levels = ha.model.list)




## Spike RBD 

# Generate all pairwise combinations and self-comparison of models
model_pairs <- combn(rbd.model.list, 2)
model_pairs_swapped <- apply(model_pairs, 2, rev)
model_pairs <- cbind(model_pairs, model_pairs_swapped)

# Loop over each pairwise combination and compare models
RBD_alt_comparison_list <- lapply(seq_len(ncol(model_pairs)), function(i) {
  compare_alt_states(model_pairs[1, i], model_pairs[2, i], rbd.alignment.size, rbd.path, RBD_gaps)
})

# Summarise identical and disagreeing states into a data frame
RBD_alt_disagreements_table <- data.frame()

for(i in 1:length(RBD_alt_comparison_list)){
  model_disagreement_data <- summarise_disagreements(RBD_alt_comparison_list[[i]], 
                          rbd.alignment.size)
    RBD_alt_disagreements_table <- rbind(RBD_alt_disagreements_table, 
                                        model_disagreement_data)
}

# Organize models by their AIC value
RBD_alt_disagreements_table$model_1 <- factor(RBD_alt_disagreements_table$model_1, levels = rev(rbd.model.list))
RBD_alt_disagreements_table$model_2 <- factor(RBD_alt_disagreements_table$model_2, levels = rbd.model.list)


```

```{r save alt all data}

misc_path <- file.path(here(), "results/empirical/misc/")

# Among-site compositional heterogeineity Alt All reconstructions
write.csv(SR_alt_comparison_list[[2]], file = file.path(misc_path, "SR_among_site_alt_data.csv"), row.names = FALSE)
write.csv(RBD_alt_comparison_list[[1]], file = file.path(misc_path, "RBD_among_site_alt_data.csv"), row.names = FALSE)
write.csv(HA_alt_comparison_list[[2]], file = file.path(misc_path, "HA_among_site_alt_data.csv"), row.names = FALSE)

# Among-lineage compositional heterogeineity Alt All reconstructions
write.csv(SR_alt_comparison_list[[1]], file = file.path(misc_path, "SR_among_lineage_alt_data.csv"), row.names = FALSE)
write.csv(HA_alt_comparison_list[[1]], file = file.path(misc_path, "HA_among_lineage_alt_data.csv"), row.names = FALSE)

```

```{r read alt all data}

sr.among.site.alt.data <- as.data.table(read.csv(file.path(misc_path, "SR_among_site_alt_data.csv")))
rbd.among.site.alt.data <- as.data.table(read.csv(file.path(misc_path, "RBD_among_site_alt_data.csv")))
ha.among.site.alt.data <- as.data.table(read.csv(file.path(misc_path, "HA_among_site_alt_data.csv")))

sr.among.lineage.alt.data <- as.data.table(read.csv(file.path(misc_path, "SR_among_lineage_alt_data.csv")))
ha.among.lineage.alt.data <- as.data.table(read.csv(file.path(misc_path, "HA_among_lineage_alt_data.csv")))


```



```{r compare parsimony vs ml ambiguity}

get_contingency_table <- function(table_1, table_2){
  
  # Set up data for analysis
  mp_data <- table_1
  ml_data <- table_2
  mp_data <- mp_data[, .(node, site, true_amb)]
  ml_data <- ml_data[, .(node, site, true_ml_amb)]

  # Organize contingency table  
  merged_data <- merge(mp_data, ml_data, by = c("node", "site"))
  setnames(merged_data, c("node", "site", "parsimony", "ml"))
  # Rows are parsimony reconstructions, columns are ML reconstructions
  contingency_table <- table(merged_data$parsimony, merged_data$ml) 

  # Calculate odds of disagreement when:
  odds_ambiguous <- contingency_table[1,1]/contingency_table[1,2]
  odds_unambiguous <- contingency_table[2,1]/contingency_table[2,2]

  # Calculate odds ratio, confidence interval and Fisher exact test
  odds_ratio <- odds_ambiguous/odds_unambiguous

  # Calculate log odds ratio 
  log_odds_ratio <- log(odds_ratio)

  # Calculate approximate standard error of the log odds ratio
  se_odds_ratio <- sqrt((1/contingency_table[1,1]) + (1/contingency_table[1,2]) + 
                          (1/contingency_table[2,1])+ (1/contingency_table[2,2]))

  # Calculate 95% confidence interval
  lower_ci <- exp(log_odds_ratio-(qnorm(0.975)*se_odds_ratio))
  upper_ci <- exp(log_odds_ratio+(qnorm(0.975)*se_odds_ratio))
  
  print("Contingency table:")
  print(contingency_table)
  print(paste("Odds of disagreement if MP ambiguous: ", signif(odds_ambiguous, digits = 3)))
  print(paste("Odds of disagreement if MP unambiguous: ", signif(odds_unambiguous, digits = 3)))
  print(paste("Odds ratio: ", signif(odds_ratio, digits = 3)))
  print(paste("Log odds ratio: ", signif(log_odds_ratio, digits = 3)))
  print(paste("Upper 95% CI: ", signif(lower_ci, digits = 3)))
  print(paste("Lower 95% CI: ", signif(upper_ci, digits = 3)))
  
  # Determine best statistical test
  chisq.test(contingency_table)$expected
  chi_test <- chisq.test(contingency_table)
  fisher_test <- fisher.test(contingency_table)
  
  print(paste("Chi-square test, statistic: ", chi_test$statistic))
  print(paste("Chi-square test, p-value: ", chi_test$p.value))
  print("If sample is to small, use Fisher's exact test p-value")
  print(paste("Fisher's exact test, p-value: ", fisher_test$p.value))
}

get_contingency_table(SR_model_comparison_list[[2]], sr.among.site.alt.data)
get_contingency_table(RBD_model_comparison_list[[1]], rbd.among.site.alt.data)
get_contingency_table(HA_model_comparison_list[[2]], ha.among.site.alt.data)

```




```{r model comparison plots}

plot.main.comparison <- function(table, color_choice){
  plot <- ggplot(table, aes(x = model_1, y = model_2)) +
  geom_tile(color = "black", fill = color_choice) +
  geom_text(aes(label = round(identical_states_percent, digits = 1)), size = 8) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        aspect.ratio = 1) +
  labs(x = "ML states",
       y = "ML states",
       fill = "Identity (%)")
  return(plot)
}

plot.alt.comparison <- function(table, color_choice){
  plot <- ggplot(table, aes(y = model_1, x = model_2)) +
  geom_tile(color = "black", fill = color_choice) +
  geom_text(aes(label = round(identical_states_percent, digits = 1)), size = 8) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        aspect.ratio = 1) +
  labs(y = "ML states",
       x = "Alt states",
       fill = "Identity (%)")
  return(plot)
}


############################################################
##### Disagreements with best SH model #####################
############################################################


SR_main_model_disagreement <- filter(SR_model_disagreements_table, model_2 != "HsMR") %>% 
                              filter(model_1 != "HsMR")
SR_main_alt_disagreement <- filter(SR_alt_disagreements_table, model_2 != "HsMR") %>% 
                              filter(model_1 != "HsMR")

HA_main_model_disagreement <- filter(HA_model_disagreements_table, model_2 != "H3") %>% 
                              filter(model_1 != "H3")
HA_main_alt_disagreement <- filter(HA_alt_disagreements_table, model_2 != "H3") %>% 
                              filter(model_1 != "H3")

str(SR_alt_disagreements_table)
str(SR_main_alt_disagreement)

# SR DBD: ER-SS vs. JTT
plot.main.comparison(SR_main_model_disagreement, "grey90")
ggsave(file = paste0(figure.path, "/SR_main_ml_disagreement.svg"))
plot.alt.comparison(SR_main_alt_disagreement, "white")
ggsave(file = paste0(figure.path, "/SR_main_alt_disagreement.svg"))

# SARS RBD: SARS-SS vs. WAG
plot.main.comparison(RBD_model_disagreements_table, "grey90")
ggsave(file = paste0(figure.path, "/RBD_main_ml_disagreement.svg"))
plot.alt.comparison(RBD_alt_disagreements_table, "white")
ggsave(file = paste0(figure.path, "/RBD_main_alt_disagreement.svg"))

# SARS RBD: H1-SS vs. FLU
plot.main.comparison(HA_main_model_disagreement, "grey90")
ggsave(file = paste0(figure.path, "/HA_main_ml_disagreement.svg"))
plot.alt.comparison(HA_main_alt_disagreement, "white")
ggsave(file = paste0(figure.path, "/HA_main_alt_disagreement.svg"))

############################################################
##### Disagreements among site-specific models #############
############################################################

SR_epistasis_model_disagreement <- filter(SR_model_disagreements_table, model_1 %in% c("C_teleta_SR", "HsMR")) %>%
                                  filter(model_2 %in% c("C_teleta_SR", "HsMR"))
SR_epistasis_alt_disagreement <- filter(SR_alt_disagreements_table, model_1 %in% c("C_teleta_SR", "HsMR")) %>%
                                  filter(model_2 %in% c("C_teleta_SR", "HsMR"))

HA_epistasis_model_disagreement <- filter(HA_model_disagreements_table, model_1 %in% c("H1", "H3")) %>% 
                                  filter(model_2 %in% c("H1", "H3"))
HA_epistasis_alt_disagreement <- filter(HA_alt_disagreements_table, model_1 %in% c("H1", "H3")) %>% 
                                  filter(model_2 %in% c("H1", "H3"))

# SR DBD: ER-SS vs. kSR-SS
plot.main.comparison(SR_epistasis_model_disagreement, "grey90")
ggsave(file = paste0(figure.path, "/SR_epistasis_ml_disagreement.svg"))
plot.alt.comparison(SR_epistasis_alt_disagreement, "white")
ggsave(file = paste0(figure.path, "/SR_epistasis_alt_disagreement.svg"))

# SARS RBD: H1-SS vs. H3-SS
plot.main.comparison(HA_epistasis_model_disagreement, "grey90")
ggsave(file = paste0(figure.path, "/HA_epistasis_ml_disagreement.svg"))
plot.alt.comparison(HA_epistasis_alt_disagreement, "white")
ggsave(file = paste0(figure.path, "/HA_epistasis_alt_disagreement.svg"))

```

```{r contingency tables}

# To have a graphic summary of the contingency table, we are going to calculate
# the odds ratio of getting a disagreement between two ML models if the site is
# ambiguous (weak phylogenetic signal) vs. if the site is unambiguous (strong
# phylogenetic signal)

get_contingency_table <- function(table){
  model_1 <- colnames(table)[3]
  model_2 <- colnames(table)[4]
  
  contingency_table <- table %>%
    group_by(true_mismatch, pars_amb) %>%
    tally() %>%
    mutate(percent = n/nrow(table)*100) %>%
    mutate(model_1 = model_1, model_2 = model_2)
  return(contingency_table)
}

# The Fisher's exact test to determine will determine if the odds ratio (OR) 
# is statistically significant. If significant, it means that knowing the site
# is ambiguous or not helps to predict if the site will present a disagreement
fisher_parsimony <- function(contingency_table){
  numbers <- contingency_table$n
  data_for_fisher <- data.frame(
    "identical" = numbers[2:1],
    "disagreement" = numbers[4:3],
    row.names = c("unambiguous", "ambiguous"),
    stringsAsFactors = FALSE
    )
  
  test <- fisher.test(t(data_for_fisher))
  
  results <- c(round(as.numeric(test$estimate), digits = 2), 
               round(test$p.value, digits = 6))
  
  return(results)
}

SR_contingency_tables <- lapply(1:6, function(i) {
  tables <- get_contingency_table(SR_model_comparison_list[[i]])
  return(tables)
})


HA_contingency_tables <- lapply(1:6, function(i) {
  tables <- get_contingency_table(HA_model_comparison_list[[i]])
  return(tables)
})

RBD_contingency_tables <- lapply(1:3, function(i) {
  tables <- get_contingency_table(RBD_model_comparison_list[[i]])
  return(tables)
})





SR_odds_ratio <- data.frame()

for(i in 1:length(SR_contingency_tables)){
  model_1 <- unique(SR_contingency_tables[[i]]$model_1)
  model_2 <- unique(SR_contingency_tables[[i]]$model_2)
  statistics <- fisher_parsimony(SR_contingency_tables[[i]])
  data <- c(model_1, model_2, statistics[1], statistics[2])
  SR_odds_ratio <- rbind(SR_odds_ratio, data)
}

colnames(SR_odds_ratio) <- c("model_1", "model_2", "odds_ratio", "p.value")
SR_odds_ratio$model_1 <- factor(SR_odds_ratio$model_1, levels = sr.model.list)
SR_odds_ratio$model_2 <- factor(SR_odds_ratio$model_2, levels = rev(sr.model.list))


HA_odds_ratio <- data.frame()

for(i in 1:length(HA_contingency_tables)){
  model_1 <- unique(HA_contingency_tables[[i]]$model_1)
  model_2 <- unique(HA_contingency_tables[[i]]$model_2)
  statistics <- fisher_parsimony(HA_contingency_tables[[i]])
  data <- c(model_1, model_2, statistics[1], statistics[2])
  HA_odds_ratio <- rbind(HA_odds_ratio, data)
}

colnames(HA_odds_ratio) <- c("model_1", "model_2", "odds_ratio", "p.value")
HA_odds_ratio$model_1 <- factor(HA_odds_ratio$model_1, levels = ha.model.list)
HA_odds_ratio$model_2 <- factor(HA_odds_ratio$model_2, levels = rev(ha.model.list))


RBD_odds_ratio <- data.frame()

for(i in 1:length(RBD_contingency_tables)){
  model_1 <- unique(RBD_contingency_tables[[i]]$model_1)
  model_2 <- unique(RBD_contingency_tables[[i]]$model_2)
  statistics <- fisher_parsimony(RBD_contingency_tables[[i]])
  data <- c(model_1, model_2, statistics[1], statistics[2])
  RBD_odds_ratio <- rbind(RBD_odds_ratio, data)
}

colnames(RBD_odds_ratio) <- c("model_1", "model_2", "odds_ratio", "p.value")
RBD_odds_ratio$model_1 <- factor(RBD_odds_ratio$model_1, levels = rbd.model.list)
RBD_odds_ratio$model_2 <- factor(RBD_odds_ratio$model_2, levels = rev(rbd.model.list))

```


```{r}

SR_contingency_tables[[2]]

analysis_contingency_tables <- function(table){

  numbers <- table$n

  # Organize 2x2 contingency table
  
  ct <- data.frame(
    "disagreement" = numbers[3:4],
    "identical" = numbers[1:2],
    row.names = c("ambiguous", "unambiguous"),
    stringsAsFactors = FALSE
  )
  
  # Calculate odds of disagreement when:
  odds_ambiguous <- numbers[3]/numbers[1]
  odds_unambiguous <- numbers[4]/numbers[2]

  # Calculate odds ratio, confidence interval and Fisher exact test
  odds_ratio <- odds_ambiguous/odds_unambiguous

  # Calculate log odds ratio 
  log_odds_ratio <- log(odds_ratio)

  # Calculate approximate standard error of the log odds ratio
  se_odds_ratio <- sqrt((1/numbers[1]) + (1/numbers[2]) + (1/numbers[3])+ (1/numbers[4]))

  # Calculate 95% confidence interval
  lower_ci <- exp(log_odds_ratio-(qnorm(0.975)*se_odds_ratio))
  upper_ci <- exp(log_odds_ratio+(qnorm(0.975)*se_odds_ratio))
  
  
  print("Contingency table:")
  print(ct)
  print(paste("Odds of disagreement if MP ambiguous: ", signif(odds_ambiguous, digits = 3)))
  print(paste("Odds of disagreement if MP unambiguous: ", signif(odds_unambiguous, digits = 3)))
  print(paste("Odds ratio: ", signif(odds_ratio, digits = 3)))
  print(paste("Log odds ratio: ", signif(log_odds_ratio, digits = 3)))
  print(paste("Upper 95% CI: ", signif(lower_ci, digits = 3)))
  print(paste("Lower 95% CI: ", signif(upper_ci, digits = 3)))
  
  # Determine best statistical test
  chisq.test(ct)$expected
  chi_test <- chisq.test(ct)
  fisher_test <- fisher.test(ct)
  
  print(paste("Chi-square test, statistic: ", chi_test$statistic))
  print(paste("Chi-square test, p-value: ", chi_test$p.value))
  print("If sample is to small, use Fisher's exact test p-value")
  print(paste("Fisher's exact test, p-value: ", fisher_test$p.value))
  
  
  
}


analysis_contingency_tables(SR_contingency_tables[[2]])
analysis_contingency_tables(RBD_contingency_tables[[1]])
analysis_contingency_tables(HA_contingency_tables[[2]])


# For epistasis data
analysis_contingency_tables(SR_contingency_tables[[1]])
analysis_contingency_tables(HA_contingency_tables[[1]])


```


```{r odds bar plot global}

extract.odds <- function(table){
  table <- as.data.frame(table)
  
  model_1 <- unique(table$model_1)
  model_2 <- unique(table$model_2)
  
  contingency_table <- as.data.frame(table)
  numbers <- table$n
  odds_ambiguous <- numbers[3]/numbers[1] # Odds of disagreements in ambiguous sites
  odds_unambiguous <- numbers[4]/numbers[2] # Odds of disagreements in unambiguous sites
  odds_ratio <- odds_ambiguous/odds_unambiguous # How many times the odds of getting disagreements in ambiguous sites than unambiguous sites
  
  odds_table <- data.frame(
    "parsimony" = c("Unambiguous", "Ambiguous"),
    "odds" = c(odds_unambiguous, odds_ambiguous),
    "model" = c(model_2, model_2),
    stringsAsFactors = TRUE
  )
  
  odds_table$parsimony <- factor(odds_table$parsimony, levels = c("Ambiguous", "Unambiguous"))
  
  return(odds_table)
  
}


plot.odds.ratio <- function(table){
  plot <- ggplot(table, aes(x = system, y = odds*100, fill = parsimony)) +
  geom_hline(yintercept = 0, color = "grey80") +  
  geom_col(color = "black", position = position_dodge()) +
    labs(x = "System",
         y = "Odds of disagreement\n(x100)",
         fill = "MP reconstruction") +
  scale_fill_manual(values = c("#F9EBDE", "#815854")) +
  theme(aspect.ratio = 1)

  return(plot)
}



############################################################
##### Disagreements with best SH model #####################
############################################################

SR_main_odds <- extract.odds(SR_contingency_tables[[2]]) # ER-SS v. JTT
SR_main_odds <- mutate(SR_main_odds, system = "SR DBD")


RBD_main_odds <- extract.odds(RBD_contingency_tables[[1]]) # SARS-SS v. WAG
RBD_main_odds <- mutate(RBD_main_odds, system = "SARS RBD")

HA_main_odds <- extract.odds(HA_contingency_tables[[2]]) # H1-SS v. FLU
HA_main_odds <- mutate(HA_main_odds, system = "HA")


All_main_odds <- rbind(SR_main_odds, RBD_main_odds, HA_main_odds)
All_main_odds$system <- factor(All_main_odds$system, levels = c("SR DBD", "SARS RBD", "HA"))

plot.odds.ratio(All_main_odds) +
    ylim(0,95) +
    geom_signif(
      annotation = c("44***", "397***", "40***"),
      y_position = c(28, 87, 38), 
      xmin = c(0.75, 1.75, 2.75), 
      xmax = c(1.25, 2.25, 3.25),
      tip_length = c(0.015,0.015)
  )

ggsave(file = paste0(figure.path, "/Main_odds_plot.svg"))



```


## How are the disagreements distributed along the phylogeny?

With the previous results in mind, it is relevant to ask if the states with disagreements between model are evenly distributed in the nodes in the phylogeny or if some nodes are more affected than others.


```{r disagreements per node}

identity_per_node <- function(model_comparison_table){
  model_comparison_table <- as.data.frame(model_comparison_table)
    model_comparison_table <- model_comparison_table %>%
      group_by(node) %>%
      count(true_mismatch, 
          name = "number_disagreements", 
          .drop = FALSE) %>%
      filter(true_mismatch == "disagreement") %>%
      ungroup() %>%
      arrange(desc(number_disagreements)) #%>%
      #mutate(cumsum = cumsum(number_disagreements)) %>%
      #mutate(total_percent = (cumsum/sum(number_disagreements))*100) %>%
      #mutate(normalized_disagreements = number_disagreements/max(number_disagreements))
  
  model_comparison_table$node <- as.character(model_comparison_table$node)
  
  model_comparison_table$node <- factor(model_comparison_table$node, 
                     levels = unique(model_comparison_table$node[order(model_comparison_table$number_disagreements, 
                                                                       decreasing = TRUE)]))

  return(model_comparison_table)
}

# The comparisons of C. teleta with HsMR, JTT and Poisson have the index 1, 2,
# and 3, respectively

# The comparisons of H1 with H3, FLU and Poisson have the index 1, 2,
# and 3, respectively

# The comparisons of SARS-CoV-2 with WAG and Poisson have the index 1, and 2,
# respectively


SR_node_identity_binned <- data.frame()
for(i in 1:3){
  identity_binned <- identity_per_node(SR_model_comparison_list[[i]])
  identity_binned <- mutate(identity_binned, model = sr.model.list[i+1])
  SR_node_identity_binned <- rbind(SR_node_identity_binned, identity_binned)
  
}


HA_node_identity_binned <- data.frame()
for(i in 1:3){
  identity_binned <- identity_per_node(HA_model_comparison_list[[i]])
  identity_binned <- mutate(identity_binned, model = ha.model.list[i+1])
  HA_node_identity_binned <- rbind(HA_node_identity_binned, identity_binned)
  
}

RBD_node_identity_binned <- data.frame()
for(i in 1:2){
  identity_binned <- identity_per_node(RBD_model_comparison_list[[i]])
  identity_binned <- mutate(identity_binned, model = rbd.model.list[i+1])
  RBD_node_identity_binned <- rbind(RBD_node_identity_binned, identity_binned)
}

```


```{r differences per node in phylogenies}

# DMSPhyloAA produces two topologies: one cladogram with ancestral nodes 
# labeled ("labeled_cladogram.txt"), and one with the estimated branch lengths,
# but without labels ("phylogram.txt"). To associate the number of disagreements
# between models and the estimated branch lenghts, we need to associate the 
# ancestral node labels to the phylograms

# The function label_ancestral_nodes extracts the labels from "labeled_cladogram.txt"
# and adds them to the "phylogram.txt" trees by using the function as_tibble()
# from the package treeio to transform tree data into tables.
label_ancestral_nodes <- function(unlabeled, labeled){
  # transform tree data into tibbles
  unlabeled_tree <- treeio::as_tibble(unlabeled)
  labeled_tree <- treeio::as_tibble(labeled)
  
  # as_tibble will produce a column named label that includes the tip names for
  # the unlabeled tree and NA values for the ancestral nodes, so we can discard
  # them
  unlabeled_tree <- select(unlabeled_tree, -label)
  
  # extract the label names and their corresponding nodes from the labeled tree
  # into a tibble
  labels <- labeled_tree$label
  nodes <- labeled_tree$node
  
  labels_for_tree <- tibble(label = labels,
              node = nodes)
  
  # combine the unlabeled tree with the labels by the node values and return the
  # new phylogram with labels
  tree_with_labels <- full_join(unlabeled_tree,
                                labels_for_tree, 
                                by = "node")
  return(tree_with_labels)
  
}

# Once the topologies with branch lengths are correctly labeled, information 
# the differences in reconstructions should be added to the tibbles so that
# inferences about can be made. add_data_to_tree accomplishes that function by
# fusing the data from the analysis of disagreements per node to the correct
# nodes in the tibble
add_data_to_tree <- function(node_identity_binned, compared_model, alignment_size, tree_table, num_tips){

  # extract data from single comparison between models and calculate identity
  # between reconstructions at a single node
  model_disagreement_data <- node_identity_binned %>%
  filter(model == compared_model) %>%
  mutate(identity = (1-number_disagreements/alignment_size)*100)
  
  # transform node columns from factors to numeric values, but preserving the
  # order
  model_disagreement_data$node <- as.numeric(levels(model_disagreement_data$node)[model_disagreement_data$node])
  
  # prepare data to merge with tree tibble format
  model_disagreement_data <- model_disagreement_data %>%
    select("node", "number_disagreements","identity") %>%
    arrange(node)
  
  # since we only have data for the ancestral nodes, we need to produce some
  # placeholder values (NA) for the tip branches and merge them with the
  # disagreement data
  tip_labels <- tree_table$label[1:num_tips+1]
  tip_data <- tibble(label = tip_labels,
         number_disagreements = NA,
         identity = NA)
  colnames(model_disagreement_data) <- c("label", "number_disagreements", "identity")
  model_disagreement_data$label <- as.character(model_disagreement_data$label)
  
  # generate tibble with all necessary data to add to the input tree tibble
  model_disagreement_data <- tibble(model_disagreement_data)
  model_disagreement_data <- bind_rows(model_disagreement_data, tip_data)
  
  # merge with tree tibble
  tree_table <- full_join(tree_table, model_disagreement_data, by = "label")
  return(tree_table)
}

# Every ancestral node is connected to its parent node and two daughter nodes
# by a certain branch length. To calculate how well connected a node is, we
# have to incorporate the info on the three branches leading to that node. The
# arithmetic mean may be a misleading number as branches can have very variable
# lengths. As such, a better measurement is the harmonic mean, that penalizes
# the effect of outliers. calc_harmonic_blens() is a function that pairs all 
# ancestral nodes with their connecting branch length values to their parent and 
# daughter nodes. Then, the function calculates the arithmetic mean and the 
# harmonic mean per node. The function adds this data to a partial tibble of
# the tree values that only contains the ancestral nodes for later plotting
calc_harmonic_blens <- function(tree_with_data, num_tips){
  
  tree_with_data <- as.data.frame(tree_with_data)
  blens_df <- data.frame()
  
  # iterate only in ancestral nodes looking for branch length values
  # given how trees are read, a fake root is incorporated into the tibble by
  # adding an unexistant node that splits the branch length in two equal pieces
  # the function corrects for that fake splitting exclusively for the extra
  # node
  for(i in seq(num_tips+2, nrow(tree_with_data))){
    node <- tree_with_data$node[i]
    parent_blens <- tree_with_data$branch.length[i]
    daughter <- c()
    
    for(j in 1:nrow(tree_with_data)){
      if(tree_with_data$node[i] == tree_with_data$parent[j]){
        if(tree_with_data$parent[i] == num_tips+1) { 
          daughter_blens <- tree_with_data$branch.length[j]*2
          daughter <- c(daughter, daughter_blens)  
        } else {
          daughter_blens <- tree_with_data$branch.length[j]
          daughter <- c(daughter, daughter_blens)
        }
      }
    }
    blens_data <- c(node, parent_blens, daughter[1], daughter[2])
    blens_df <- rbind(blens_df, blens_data)
  }
  # rename for clarity
  colnames(blens_df) <- c("node", "parent", "daughter_1", "daughter_2")
  
  # calculate arithmentic mean and harmonic mean
  blens_df <- blens_df %>% 
    rowwise() %>%
    mutate(mean = mean(c(parent, daughter_1, daughter_2))) %>%
    mutate(harmonic_mean = psych::harmonic.mean(c(parent, daughter_1, daughter_2))) %>%
    select(c(node,mean, harmonic_mean))
  
  # merge data with tree tibble and then eliminate tip nodes from the table
  tree_with_data <- full_join(tree_with_data, blens_df, by = "node")
  ancestors_with_data <- filter(tree_with_data, node >= num_tips+2)
  return(ancestors_with_data)

}


# Load SR topologies
SR_tree_labels <- read.newick(paste0(sr.path, "/C_teleta_SR/labeled_cladogram.txt"))
SR_topologies <- lapply(c(paste0(sr.path, "/C_teleta_SR/phylogram.txt"),
                          paste0(sr.path, "/Protostome_SR/phylogram.txt"),
                          paste0(sr.path, "/HsMR/phylogram.txt"),
                          paste0(sr.path, "/JTT/phylogram.txt"),
                          paste0(sr.path, "/Poisson/phylogram.txt")), 
                          read.newick)

# Load HA topologies
HA_tree_labels <- read.newick(paste0(ha.path, "/H1/labeled_cladogram.txt"))
HA_topologies <- lapply(c(paste0(ha.path, "/H1/phylogram.txt"),
                          paste0(ha.path, "/H3/phylogram.txt"),
                          paste0(ha.path, "/FLU/phylogram.txt"),
                          paste0(ha.path, "/Poisson/phylogram.txt")),
                          read.newick)

# Load RBD topologies
RBD_tree_labels <- read.newick(paste0(rbd.path, "/SARS_CoV_2/labeled_cladogram.txt"))
RBD_topologies <- lapply(c(paste0(rbd.path, "/SARS_CoV_2/phylogram.txt"),
                           paste0(rbd.path, "/WAG/phylogram.txt"),
                           paste0(rbd.path, "/Poisson/phylogram.txt")),
                           read.newick)


SR_topology_tables <- lapply(SR_topologies, label_ancestral_nodes, SR_tree_labels)
names(SR_topology_tables) <- sr.model.list[1:length(SR_topology_tables)]

HA_topology_tables <- lapply(HA_topologies, label_ancestral_nodes, HA_tree_labels)
names(HA_topology_tables) <- ha.model.list[1:length(HA_topology_tables)]

RBD_topology_tables <- lapply(RBD_topologies, label_ancestral_nodes, RBD_tree_labels)
names(RBD_topology_tables) <- rbd.model.list[1:length(RBD_topology_tables)]


SR_topology_tables_with_data <- lapply(2:4, function(i) {
  tree_with_data <- add_data_to_tree(SR_node_identity_binned, sr.model.list[i], sr.alignment.size, SR_topology_tables[[i]], sr.tips)
  return(tree_with_data)
})
names(SR_topology_tables_with_data) <- sr.model.list[2:4]

HA_topology_tables_with_data <- lapply(2:4, function(i) {
  tree_with_data <- add_data_to_tree(HA_node_identity_binned, ha.model.list[i], ha.alignment.size, HA_topology_tables[[i]], ha.tips)
  return(tree_with_data)
})
names(HA_topology_tables_with_data) <- ha.model.list[2:4]

RBD_topology_tables_with_data <- lapply(2:3, function(i) {
  tree_with_data <- add_data_to_tree(RBD_node_identity_binned, rbd.model.list[i], rbd.alignment.size, RBD_topology_tables[[i]], rbd.tips)
  return(tree_with_data)
})
names(RBD_topology_tables_with_data) <- rbd.model.list[2:3]



############################################################
##### Calculate harmonic branch lengths ####################
############################################################



SR_harmonic_blens <- data.frame()

for(i in 1:length(SR_topology_tables_with_data)){
  harmonic_df <- calc_harmonic_blens(SR_topology_tables_with_data[[i]], sr.tips)
  harmonic_df <- mutate(harmonic_df, model = names(SR_topology_tables_with_data)[i])
  SR_harmonic_blens <- rbind(SR_harmonic_blens, harmonic_df)
}


HA_harmonic_blens <- data.frame()

for(i in 1:length(HA_topology_tables_with_data)){
  harmonic_df <- calc_harmonic_blens(HA_topology_tables_with_data[[i]], ha.tips)
  harmonic_df <- mutate(harmonic_df, model = names(HA_topology_tables_with_data)[i])
  HA_harmonic_blens <- rbind(HA_harmonic_blens, harmonic_df)
}

RBD_harmonic_blens <- data.frame()

for(i in 1:length(RBD_topology_tables_with_data)){
  harmonic_df <- calc_harmonic_blens(RBD_topology_tables_with_data[[i]], rbd.tips)
  harmonic_df <- mutate(harmonic_df, model = names(RBD_topology_tables_with_data)[i])
  RBD_harmonic_blens <- rbind(RBD_harmonic_blens, harmonic_df)
}


```


```{r plot harmonic mean}
plot.harmonic.mean <- function(table, colors, shapes){
  plot <- ggplot(table, aes(x = harmonic_mean, y = number_disagreements, color = model, shape = model)) +
    geom_hline(yintercept = 0, color = "grey80") +
    geom_vline(xintercept = 0, color = "grey80") +
    geom_point(size = 2.5, stroke = 1.2) +
    scale_color_manual(values = colors) +
    scale_shape_manual(values = shapes) +
    labs(y = "# disagreements between reconstructions",
         x = "Harmonic mean branch length",
         color = "Model",
         shape = "Model") +
    theme_classic() +
    theme(aspect.ratio = 1)
  
  return(plot)
}

calculate.correlation <- function(table, model){
  filtered_table <- filter(table, model == model)
  print(cor.test(filtered_table$harmonic_mean, filtered_table$number_disagreements, method = "spearman"))
}

SR_harmonic_blens$model <- factor(SR_harmonic_blens$model, levels = sr.model.list)
HA_harmonic_blens$model <- factor(HA_harmonic_blens$model, levels = ha.model.list)
RBD_harmonic_blens$model <- factor(RBD_harmonic_blens$model, levels = rbd.model.list)


############################################################
##### Disagreements with best SH model #####################
############################################################


plot.harmonic.mean(filter(SR_harmonic_blens, model == "JTT"), "#D81B60", 2)
calculate.correlation(SR_harmonic_blens, "JTT")
calculate.correlation(filter(SR_harmonic_blens, label != 75), "JTT") # Without outlier in node 75
ggsave(file = paste0(figure.path, "/SR_main_harmonic.svg"))

plot.harmonic.mean(filter(RBD_harmonic_blens, model == "WAG"), "#D81B60", 2)
calculate.correlation(RBD_harmonic_blens, "WAG")
ggsave(file = paste0(figure.path, "/RBD_main_harmonic.svg"))

plot.harmonic.mean(filter(HA_harmonic_blens, model == "FLU"), "#D81B60", 2)
calculate.correlation(HA_harmonic_blens, "FLU")
ggsave(file = paste0(figure.path, "/HA_main_harmonic.svg"))

```



```{r}

plot.entropy.boxplot <- function(table){
  table$true_mismatch <- factor(table$true_mismatch, levels = c("identical", "disagreement"))
  plot <- ggplot(table, aes(x = system, y = entropy, fill = true_mismatch)) +
    geom_hline(yintercept = c(0, 0.5, 1), linetype = "dashed", color = "grey50") +
    geom_boxplot(alpha = 0.8, width = 0.5) +
    scale_fill_manual(values = c("#FFDFB9", "#A4193D")) +
    scale_y_continuous(breaks = seq(0, 1, 0.25), limits = c(0,1)) +
    theme(aspect.ratio = 1) +
    labs(x = "Type of reconstruction",
         y = "Sequence entropy",
         fill = "Reconstruction \nbetween models")
    
  
  return(plot)
}

plot.rates.boxplot <- function(table){
  table$true_mismatch <- factor(table$true_mismatch, levels = c("identical", "disagreement"))
  plot <- ggplot(table, aes(x = system, y = rates, fill = true_mismatch)) +
    geom_hline(yintercept = 1, linetype = "dashed", color = "grey50") +
    geom_boxplot(alpha = 0.8, width = 0.5) +
    scale_fill_manual(values = c("#FFDFB9", "#A4193D")) +
    scale_y_continuous(breaks = seq(0, 6, 1), limits = c(0,6.5)) +
    theme(aspect.ratio = 1)+
    labs(x = "Type of reconstruction",
         y = "Rate of evolution",
         fill = "Reconstruction \nbetween models")
  
  
  
  return(plot)
}

get_ks_test <- function(data){
  table <- data
  
  parameters <- c("rate of evolution", "sequence entropy")
  statistic <- c()
  p.value <- c()
  
  set.seed(817685)
  table <- table[sample(nrow(table), 1000)]
  
  group1 <- table$rates[table$true_mismatch == "identical"]
  group2 <- table$rates[table$true_mismatch == "disagreement"]
  results <- wilcox.test(group2, group1, paired = FALSE, alternative = "g", conf.int = TRUE)
  print(results)
  statistic <- c(statistic, as.numeric(results$statistic))
  p.value <- c(p.value, results$p.value)
  
  group1 <- table$entropy[table$true_mismatch == "identical"]
  group2 <- table$entropy[table$true_mismatch == "disagreement"]
  #results <- ks.test(group2, group1)
  results <- wilcox.test(group2, group1, paired = FALSE, alternative = "g", conf.int = TRUE)
  print(results)
  statistic <- c(statistic, as.numeric(results$statistic))
  p.value <- c(p.value, results$p.value)
  
  df <- data.frame(parameters, statistic, p.value)
  
  print(paste("Asymptotic two-sample Kolmogorov-Smirnov test of", colnames(table[,3]), "and", colnames(table[,4])))
  return(df)
  
}


SR_nodes_with_dis <- unique(filter(SR_node_identity_binned, number_disagreements > 0)$node)
count(filter(SR_model_comparison_list[[2]], node %in% SR_nodes_with_dis), true_mismatch == "identical")

RBD_nodes_with_dis <- unique(filter(RBD_node_identity_binned, number_disagreements > 0)$node)
count(filter(RBD_model_comparison_list[[1]], node %in% RBD_nodes_with_dis), true_mismatch == "identical")


HA_nodes_with_dis <- unique(filter(HA_node_identity_binned, number_disagreements > 0)$node)
count(filter(HA_model_comparison_list[[2]], node %in% HA_nodes_with_dis), true_mismatch == "identical")


filter.node.data <- function(table, list_disagreements){
  filtered_table <- table %>%
  filter(node %in% list_disagreements) %>%
  select(c(true_mismatch, rates, entropy))
  
  return(filtered_table)
}

############################################################
##### Disagreements with best SH model #####################
############################################################

SR_main_node_data <- filter.node.data(SR_model_comparison_list[[2]], SR_nodes_with_dis) %>% mutate(system = "SR DBD")
RBD_main_node_data <- filter.node.data(RBD_model_comparison_list[[1]], RBD_nodes_with_dis) %>% mutate(system = "SARS RBD")
HA_main_node_data <- filter.node.data(HA_model_comparison_list[[2]], HA_nodes_with_dis) %>% mutate(system = "HA")


All_main_node_data <- rbind(SR_main_node_data, RBD_main_node_data, HA_main_node_data)
All_main_node_data$system <- factor(All_main_node_data$system, levels = c("SR DBD", "SARS RBD", "HA"))

get_ks_test(SR_model_comparison_list[[2]])
get_ks_test(RBD_model_comparison_list[[1]])
get_ks_test(HA_model_comparison_list[[2]])


All_main_node_data %>%
  group_by(system, true_mismatch) %>%
  summarise(median_rates = median(rates),
            median_entropy = median(entropy))

plot.rates.boxplot(All_main_node_data) +
    geom_signif(
      annotation = "***",
      y_position = c(5.5, 6.3, 4.5), 
      xmin = c(0.875, 1.875, 2.875), 
      xmax = c(1.125, 2.125, 3.125),
      tip_length = c(0.015,0.015)
  )

ggsave(file = paste0(figure.path, "/Main_rates_plot.svg"))

plot.entropy.boxplot(All_main_node_data) + 
    geom_signif(
      annotation = "***",
      y_position = c(0.70, 0.70, 0.9), 
      xmin = c(0.875, 1.875, 2.875), 
      xmax = c(1.125, 2.125, 3.125),
      tip_length = c(0.015,0.015)
  )


ggsave(file = paste0(figure.path, "/Main_entropy_plot.svg"))

All_main_node_data %>%
  group_by(system, true_mismatch) %>%
  summarise(median_rate = median(rates),
            median_entropy = median(entropy))


############################################################
##### Disagreements among site-specific models #############
############################################################


SR_epistasis_node_data <- filter.node.data(SR_model_comparison_list[[1]], SR_nodes_with_dis) %>% mutate(system = "SR DBD")
HA_epistasis_node_data <- filter.node.data(HA_model_comparison_list[[1]], HA_nodes_with_dis) %>% mutate(system = "HA")


All_epistasis_node_data <- rbind(SR_epistasis_node_data, HA_epistasis_node_data)
All_epistasis_node_data$system <- factor(All_epistasis_node_data$system, levels = c("SR DBD", "HA"))

get_ks_test(SR_model_comparison_list[[1]])
get_ks_test(HA_model_comparison_list[[1]])


plot.rates.boxplot(All_epistasis_node_data) +
    geom_signif(
      annotation = "***",
      y_position = c(5.5, 4.5), 
      xmin = c(0.875, 1.875), 
      xmax = c(1.125, 2.125),
      tip_length = c(0.015,0.015)
  )

ggsave(file = paste0(epistasis.figure.path, "/rates.plot.svg"))

plot.entropy.boxplot(All_epistasis_node_data)  + 
    geom_signif(
      annotation = "***",
      y_position = c(0.7, 0.9), 
      xmin = c(0.875, 1.875), 
      xmax = c(1.125, 2.125),
      tip_length = c(0.015,0.015)
  )

ggsave(file = paste0(epistasis.figure.path, "/entropy.plot.svg"))


All_epistasis_node_data %>%
  group_by(system, true_mismatch) %>%
  summarise(median_rate = median(rates),
            median_entropy = median(entropy))


```



```{r kolmogorov smirnoff}

get_ks_test <- function(data){
  table <- data
  
  parameters <- c("rate of evolution", "sequence entropy")
  
  
  group1 <- table$rates[table$true_mismatch == "identical"]
  group2 <- table$rates[table$true_mismatch == "disagreement"]
  results <- ks.test(group2, group1)
  print(paste("Kolmogorov-Smirnov test of", parameters[1]))
  print(paste0("D(", length(group1),",", length(group2), ") = ", signif(results$statistic, digits = 4), ", p = ", signif(results$p.value, digits = 3)))
  
  group1 <- table$entropy[table$true_mismatch == "identical"]
  group2 <- table$entropy[table$true_mismatch == "disagreement"]
  results <- ks.test(group2, group1)
  print(paste("Kolmogorov-Smirnov test of", parameters[2]))
  print(paste0("D(", length(group1),",", length(group2), ") = ", signif(results$statistic, digits = 4), ", p = ", signif(results$p.value, digits = 3)))
  
}



get_ks_test(SR_model_comparison_list[[2]])
get_ks_test(RBD_model_comparison_list[[1]])
get_ks_test(HA_model_comparison_list[[2]])


get_ks_test(SR_model_comparison_list[[1]])
get_ks_test(HA_model_comparison_list[[1]])


```




```{r parsimony odds ratio}
summarise_parsimony_data <- function(model_comparison_list, parsimony_data){

  parsimony_list <- list()
  parsimony_table <- as.data.frame(model_comparison_list)
  parsimony_table <- cbind(parsimony_table,parsimony_data)
  
  for(i in 1:nrow(parsimony_table)){
    if(parsimony_table[i, 6] == "gap"){
      parsimony_table[i, 3] <- "-"
      parsimony_table[i, 4] <- "-"
      parsimony_table[i, 8] <- "unambiguous"
      parsimony_table[i, 9] <- "-"
    }
  }
  
  #Do the disagreements among models accumulate in states that are reconstructed
  #ambiguously by parsimony?
  global_parsimony <- parsimony_table %>%
    group_by(true_mismatch,pars_amb) %>%
    tally() %>%
    mutate(percent = n/nrow(parsimony_table)*100)
  
  
  parsimony_list[[1]] <- global_parsimony
  
  #In parsimony unambiguous sites with disagreements, which model assigns the MP state?
  parsimony_unambiguous <- parsimony_table %>%
    filter(pars_amb == "unambiguous") %>%
    filter(true_mismatch == "Disagreement")
  
  
  
  parsimony_unambiguous <- data.frame(number = c(sum(parsimony_unambiguous[,3] == parsimony_unambiguous[,9]),
                        sum(parsimony_unambiguous[,4] == parsimony_unambiguous[,9]))) %>%
    mutate(percent = number/nrow(parsimony_unambiguous))
             
  row.names(parsimony_unambiguous) <- c("MP_in_SS_model", "MP_in_compared_model")
  parsimony_list[[2]] <- parsimony_unambiguous
  
  #In parsimony ambiguous sites with disagreements, is the assigned state part of 
  #the MP set?
  parsimony_ambiguous <- parsimony_table %>%
    filter(pars_amb == "ambiguous") %>%
    filter(true_mismatch == "Disagreement")
  
  parsimony_ambiguous <- data.frame(number = c(sum(str_detect(parsimony_ambiguous[,9], parsimony_ambiguous[,3])),
             sum(str_detect(parsimony_ambiguous[,9], parsimony_ambiguous[,4])))) %>%
    mutate(percent = number/nrow(parsimony_ambiguous))
  
  row.names(parsimony_ambiguous) <- c("MP_set_SS_model", "MP_set_compared_model")
  parsimony_list[[3]] <- parsimony_ambiguous
  
  
  #Are identical reconstructions in parsimony ambiguous sites always within the
  #MP set?
  parsimony_identical <- parsimony_table %>%
    filter(pars_amb == "ambiguous") %>%
    filter(true_mismatch == "Identical")
  
  parsimony_identical <- data.frame(number = c(sum(str_detect(parsimony_identical[,9], parsimony_identical[,3])),
                        sum(str_detect(parsimony_identical[,9], parsimony_identical[,4])))) %>%
    mutate(percent = number/nrow(parsimony_identical))
  
  row.names(parsimony_identical) <- c("within_MP_set_SS_model", "within_MP_set_compared_model")
  
  parsimony_list[[4]] <- parsimony_identical
  
  return(parsimony_list)
}



SR_Poisson_parsimony <- summarise_parsimony_data(SR_model_comparison_list[[2]], SR_parsimony)
SR_JTT_parsimony <- summarise_parsimony_data(SR_model_comparison_list[[3]], SR_parsimony)
SR_HsMR_parsimony <- summarise_parsimony_data(SR_model_comparison_list[[4]], SR_parsimony)

HA_Poisson_parsimony <- summarise_parsimony_data(HA_model_comparison_list[[2]], HA_parsimony)
HA_FLU_parsimony <- summarise_parsimony_data(HA_model_comparison_list[[3]], HA_parsimony)
HA_H3_parsimony <- summarise_parsimony_data(HA_model_comparison_list[[4]], HA_parsimony)

RBD_Poisson_parsimony <- summarise_parsimony_data(RBD_model_comparison_list[[2]], RBD_parsimony)
RBD_WAG_parsimony <- summarise_parsimony_data(RBD_model_comparison_list[[3]], RBD_parsimony)

```


## Among-lineage compositional heterogeneity

```{r epistasis preference comparison}

find_max_amino_acid <- function(row) {
  max_pref <- max(row)
  amino_acid <- names(row[row == max_pref])
  return(amino_acid)
}

clean.preference.data <- function(main_data, sec_data) {
  colnames(main_data) <- aa_order
  colnames(sec_data) <- aa_order
  
  highest_pref_amino_acid_main <- apply(main_data, 1, find_max_amino_acid)
  highest_pref_amino_acid_sec <- apply(sec_data, 1, find_max_amino_acid)
  
  main_data_long <- melt(main_data, id.vars = NULL, 
                         variable.name = "amino_acid", 
                         value.name = "main_preference")
  
  sec_data_long <- melt(sec_data, 
                        id.vars = NULL, 
                        variable.name = "amino_acid", 
                        value.name = "secondary_preference")
  
  merged_data <- cbind(main_data_long, 
                       secondary_preference = sec_data_long$secondary_preference)
  
  merged_data$highest_main_pref <- rep(highest_pref_amino_acid_main, 
                                       length.out = nrow(merged_data))
  
  merged_data$highest_sec_pref <- rep(highest_pref_amino_acid_sec, 
                                      length.out = nrow(merged_data))
  
  merged_data$match_main <- merged_data$highest_main_pref == merged_data$amino_acid
  merged_data$match_sec <- merged_data$highest_sec_pref == merged_data$amino_acid
  
  return(merged_data)
  
}


aa_order <- c("A","R","N","D","C","Q","E","G","H","I",
              "L","K","M","F","P","S","T","W","Y","V")

er.data <- read.csv(paste0(sr.path,"/C_teleta_SR/AAPI.txt"), sep = " ", header = FALSE)
mr.data <- read.csv(paste0(sr.path,"/HsMR/AAPI.txt"), sep = " ", header = FALSE)
h1.data <- read.csv(paste0(ha.path,"/H1/AAPI.txt"), sep = " ", header = FALSE)
h3.data <- read.csv(paste0(ha.path,"/H3/AAPI.txt"), sep = " ", header = FALSE)


sr.preferences.data <- clean.preference.data(er.data, mr.data)
ha.preferences.data <- clean.preference.data(h1.data, h3.data)


# Function to calculate the result based on combinations
calculate_result <- function(main, sec) {
  if (main & sec) {
    return("overlap")
  } else if (main) {
    return("main")
  } else if (sec) {
    return("secondary")
  } else {
    return("None")
  }
}

# Apply the function to each row of the data frame and store the result in a new column



preference.overlap <- function(preferences.data){
  preferences.data$overlap <- mapply(calculate_result, preferences.data$match_main, preferences.data$match_sec)
  preferences.data$overlap <- factor(preferences.data$overlap, levels = c("None", "main", "secondary", "overlap"))
  filtered.preferences.overlap <- filter(preferences.data, overlap != "None")
  
  return(filtered.preferences.overlap)

}

sr.preferences.overlap <- preference.overlap(sr.preferences.data)
ha.preferences.overlap <- preference.overlap(ha.preferences.data)

plot.preference.overlap <- function(data, main.model, sec.model){
  ggplot(arrange(data, overlap), aes(x = main_preference, y = secondary_preference, color = overlap, shape = overlap)) +
    geom_abline(slope = 1, intercept = 0, color = "grey40") +
    geom_point(alpha = 0.75, size = 2, stroke = 1.2) +
    scale_color_manual(values = c("#1E88E5", "#004D40", "brown")) +
    scale_shape_manual(values = c(1, 6, 5)) +
    xlim(c(0,1)) +
    ylim(c(0,1)) +
    labs(x = main.model,
         y = sec.model) +
    theme(aspect.ratio = 1,
          legend.position = "none")

}

plot.preference.overlap(sr.preferences.overlap, "ER-SS", "MR-SS")
cor.test(sr.preferences.overlap$main_preference, sr.preferences.overlap$secondary_preference)
ggsave(file = paste0(epistasis.figure.path, "/sr.preference.overlap.svg"))

plot.preference.overlap(ha.preferences.overlap, "H1-SS", "H3-SS")
cor.test(ha.preferences.overlap$main_preference, ha.preferences.overlap$secondary_preference)
ggsave(file = paste0(epistasis.figure.path, "/ha.preference.overlap.svg"))

```



```{r epistasis odds ratio}

############################################################
##### Disagreements among site-specific models #############
############################################################


SR_epistasis_odds <- extract.odds(SR_contingency_tables[[1]]) # ER-SS v. kSR-SS
SR_epistasis_odds <- mutate(SR_epistasis_odds, system = "SR DBD")

HA_epistasis_odds <- extract.odds(HA_contingency_tables[[1]]) # H1-SS v. H3-SS
HA_epistasis_odds <- mutate(HA_epistasis_odds, system = "HA")


All_epistasis_odds <- rbind(SR_epistasis_odds, HA_epistasis_odds)
All_epistasis_odds$system <- factor(All_epistasis_odds$system, levels = c("SR DBD", "HA"))

plot.odds.ratio(All_epistasis_odds) +
    ylim(0,50) +
    geom_signif(
      annotation = c("49***", "42***"),
      y_position = c(20, 40), 
      xmin = c(0.75, 1.75), 
      xmax = c(1.25, 2.25),
      tip_length = c(0.015,0.015)
  )


ggsave(file = paste0(epistasis.figure.path, "/odds.ratios.svg"))


```


```{r}


############################################################
##### Disagreements among site-specific models #############
############################################################


plot.harmonic.mean(filter(SR_harmonic_blens, model == "HsMR"), "#004D40", 6)
calculate.correlation(SR_harmonic_blens, "HsMR")
calculate.correlation(filter(SR_harmonic_blens, label != 75), "HsMR") # Without outlier in node 75
ggsave(file = paste0(epistasis.figure.path, "/sr.harmonic.blens.svg"))

plot.harmonic.mean(filter(HA_harmonic_blens, model == "H3"), "#004D40", 6)
calculate.correlation(HA_harmonic_blens, "H1")
ggsave(file = paste0(epistasis.figure.path, "/ha.harmonic.blens.svg"))

```


## Supplementary material

```{r calculate phenotypic effects}

library(phylotools)
library(data.table)
library(moments)
library(dplyr)
library(here)
library(ggplot2)

supp.figure.path <- file.path(here(), "figures/supplementary/")


# define function to associate a protein sequence to their preference values
match_aa_states <- function(sequence, phenotypic_effects) {
  # split the protein sequence into individual amino acids
  amino_acids <- strsplit(sequence, "")[[1]]
  
  # initialize a vector to store the matched effects
  matched_effects <- vector(length = length(amino_acids))
  
  # match the amino acids to their corresponding phenotypic effects in the table
  for (i in seq_along(amino_acids)) {
    aa <- amino_acids[i]
    col <- match(aa, names(phenotypic_effects))
    row <- i
    matched_effects[i] <- phenotypic_effects[row, col]
  }
  
  # return the vector of matched effects
  return(matched_effects)
}

system_sequences <- read.fasta(file.path(here(), "data/alignments/all_systems_reference_seq.fasta"))

sr_dms <- read.csv(file.path(here(), "data/dms_datasets/PHI_C_teleta_SR.csv"), header = TRUE)
rbd_dms <- read.csv(file.path(here(), "data/dms_datasets/PHI_RBD_gapless.csv"), header = TRUE)
ha_dms <- read.csv(file.path(here(), "data/dms_datasets/PHI_H1.csv"), header = TRUE)


sr_phenotype <- match_aa_states(system_sequences$seq.text[1], sr_dms)
rbd_phenotype <- match_aa_states(system_sequences$seq.text[3], rbd_dms)
ha_phenotype <- match_aa_states(system_sequences$seq.text[4], ha_dms)

get_dfe <- function(dataset, sequence){
  pheno_effects <- c()
  
  for(i in 1:length(sequence)){
    effects <- as.numeric(dataset[i,] - sequence[i])
    pheno_effects <- c(pheno_effects, effects)
  }
  
  pheno_effects <- pheno_effects[pheno_effects!=0]
  
  df <- data.frame(p_effects = pheno_effects)
  return(df)
  
}

sr_dfe <- get_dfe(sr_dms, sr_phenotype)
rbd_dfe <- get_dfe(rbd_dms, rbd_phenotype)
ha_dfe <- get_dfe(ha_dms, ha_phenotype)


ggplot(sr_dfe, aes(x = p_effects)) +
  geom_density()


sr_disagreements <- SR_model_comparison_list[[2]]
sr_disagreements <- filter(sr_disagreements, true_mismatch == "disagreement")


rbd_disagreements <- RBD_model_comparison_list[[1]]
rbd_disagreements <- filter(rbd_disagreements, true_mismatch == "disagreement")

ha_disagreements <- HA_model_comparison_list[[2]]
ha_disagreements <- filter(ha_disagreements, true_mismatch == "disagreement")


get_difference_phenotypic_effects <- function(disagreements, dataset) {
  pheno_effects <- c()
  for(i in 1:nrow(disagreements)) {
    
    row <- as.numeric(disagreements[i,2])
    ss_state <- as.character(disagreements[i, 3])
    sh_state <- as.character(disagreements[i, 4])
  
    col <- match(ss_state, names(dataset))
    ss_effect <- dataset[row, col]

    col <- match(sh_state, names(dataset))
    sh_effect <- dataset[row, col]
  
    effect <- sh_effect - ss_effect
    pheno_effects <- c(pheno_effects, effect)

  }

  df <- data.frame(p_effects = pheno_effects)
  return(df)
}

sr_diff_effects <- get_difference_phenotypic_effects(sr_disagreements, sr_dms)
rbd_diff_effects <- get_difference_phenotypic_effects(rbd_disagreements, rbd_dms)
ha_diff_effects <- get_difference_phenotypic_effects(ha_disagreements, ha_dms)

plot_dfe <- function(dms_dfe, recons_dfe){
  plot <- ggplot(dms_dfe, aes(x = p_effects)) +
  geom_density(fill = "lightblue", alpha = 0.5) +
  geom_density(data = recons_dfe, aes(x = p_effects), fill = "pink", alpha = 0.5) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  geom_hline(yintercept = 0, color = "grey50") +
  labs(x = "Difference in functional effects",
       y = "Density")

  return(plot)
}

plot_dfe(sr_dfe, sr_diff_effects)
ggsave(file = paste0(supp.figure.path, "/dfe.sr.svg"))

plot_dfe(rbd_dfe, rbd_diff_effects)
ggsave(file = paste0(supp.figure.path, "/dfe.rbd.svg"))

plot_dfe(ha_dfe, ha_diff_effects)
ggsave(file = paste0(supp.figure.path, "/dfe.ha.svg"))





```


```{r Likelihood data processing, echo=FALSE}

extract_logLik <- function(model_list, model_path, param_vector) {
  # Read the log-likelihood values for each model
  logLik_local <- sapply(model_list, function(model) {
    inferred_parameters <- readLines(file.path(model_path, model, "inferred_parameters.txt"))
    # Extract the log-likelihood value from the last line of the file
    as.numeric(strsplit(inferred_parameters[length(inferred_parameters)], split = " ")[[1]][3])
  })
  
  # Compute AIC and delta AIC
  aic <- -2 * logLik_local + 2 * param_vector
  delta_aic <- aic - min(aic)
  
  # Create a data frame with the log-likelihood values, delta AIC, and the number of parameters used in the model
  logLik_table <- data.frame(model = model_list, logLik = logLik_local, delta_aic, parameters = param_vector)
  logLik_table$model <- factor(logLik_table$model, levels = model_list)
  
  # Compute the differences in log-likelihood values and create a table
  delta_logLik <- diff(logLik_local)
  delta_model <- model_list[-1]
  delta_logLik_table <- data.frame(delta_model, delta_logLik)
  
  # Return a list of the two tables
  Likelihood_tables <- list(logLik_table, delta_logLik_table)
  return(Likelihood_tables)
}

SR_num_param <- c(rep(12, 11), 20, 1)
HA_num_param <- c(12, 12, 20, 1)
RBD_num_param <- c(12, 20, 1)

SR_logLik <- extract_logLik(sr.model.list, sr.path, SR_num_param)
HA_logLik <- extract_logLik(model.list, ha.path, HA_num_param)
RBD_logLik <- extract_logLik(rbd.model.list, rbd.path, RBD_num_param)


knitr::kable(arrange(SR_logLik[[1]], delta_aic), caption = "Steroid receptor")
knitr::kable(arrange(HA_logLik[[1]], delta_aic), caption = "Hemagglutinin")
knitr::kable(arrange(RBD_logLik[[1]], delta_aic), caption = "SARS-CoV RBD")



```

```{r Likelihood plots, echo=FALSE}

plot_delta_logLik <- function(delta_logLik_table){

  delta_logLik_table <- as.data.frame(delta_logLik_table)
  
  ggplot(delta_logLik_table, aes(x = delta_model, 
                               y = delta_logLik, 
                               fill = delta_model)) +
  geom_col(color = "black") +
  geom_text(aes(label = round(delta_logLik, 
                              digits = 2)), 
            position = position_dodge(width = 0.9), 
            vjust = -0.25) +
  #scale_fill_manual(values = delta_colors) +
  geom_hline(yintercept = 0) +
  labs(x = "Model",
       y =  expression(paste(Delta, " ln-Lik (experimental - BEST)")) ,
       fill = "Model") +
  theme(legend.position = "none",
        axis.text.x = element_text(angle= 25, 
                                   vjust = 1, 
                                   hjust = 1))
}


SR_delta_logLik_plot <- plot_delta_logLik(SR_logLik[2]) +
  scale_fill_manual(values = c(rep("#7b3294", times = 8), #ER background
            rep("#008b80", times = 4), #kSR background
            "#d55e00")) + #Poisson model
  labs(caption = paste0("BEST ln-Lik =", 
                        as.character(round(SR_logLik[[1]][1,2], digits = 2))))

HA_delta_logLik_plot <- plot_delta_logLik(HA_logLik[2]) +
  scale_fill_manual(values = c("#7b3294", #H1 background
            "#008b80", #H3 background
            "#d55e00")) + #Poisson model
  labs(caption = paste0("BEST ln-Lik =", 
                        as.character(round(HA_logLik[[1]][1,2], digits = 2))))


RBD_delta_logLik_plot <- plot_delta_logLik(RBD_logLik[2]) +
  scale_fill_manual(values = c("#7b3294",
            "#d55e00")) + #Poisson model
  labs(caption = paste0("BEST ln-Lik =", 
                        as.character(round(RBD_logLik[[1]][1,2], digits = 2))))

SR_delta_logLik_plot
HA_delta_logLik_plot
RBD_delta_logLik_plot




#ggsave(file = paste0(figure.path, "/SR_delta_logLik_plot.svg"), 
#       plot = SR_delta_logLik_plot, width = 17, height = 12, 
#       units = "cm", dpi = 300)

```

